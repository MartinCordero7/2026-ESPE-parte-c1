La  clase File representa un archivo almacenado en el sistema de archivos del ordenador. Cada file individual representa un recurso utilizado por un sistema de software (por ejemplo, para mostrar una imagen en una página web). Un file puede ser de dos tipos: un  archivo PROPERTY (que contiene pares clave=valor, como DATE=20250919) o una IMAGE (en formato PNG de 8 bits).  

La arquitectura del sistema de software se muestra en Figura 1. 
El content del file se implementa como un ArrayList<Character>.  Esta estructura de datos permite tanto la representación de:
•	caracteres Unicode (UTF-16) para los pares clave=valor, y 
•	Los caracteres UTF-8 necesarios para el formato PNG de 8 bits, es decir, solo se usa el byte menos significativo  (usando valores en el intervalo [0, 255]).

Implementación requerida de la clase File

La  clase File toma los siguientes valores durante la instanciación:
c	content deberá estar vacío, pero no null.

 Se deben implementar los siguientes métodos de la clase File: 

•	void addProperty(char[] newcontent)
Este método añade un par clave=valor al content de un file
c	newcontent se añade al content existente. 
c	Si newcontent es null, se lanzará una InvalidContentException.
c	Si el type del file es IMAGE, se lanzará una excepción WrongFileTypeException.


•	long getCRC32()
Este método calcula el CRC32 (código de redundancia cíclica) del content del file
c	Se devuelve el valor CRC32. Este CRC32 se proporciona como un long mediante el método calculateCRC32() de la clase FileUtils. El método calculateCRC32() no puede manejar directamente un ArrayList<Character>.  content debe transformarse en un byte[] antes de usar el método calculateCRC32().  
c	Dado que calculateCRC32() no admite arrays vacíos, si content está vacío, getCRC32()devolverá el valor 0 (cero).


char c = 'A'; // example: 'A' = 65 (0x0041)
// get least significant byte as int
int lsb = c & 0x00FF;
// get most significant byte as int
int msb = (c >>> 8) & 0xFF;
// if you need it specifically as a byte type
byte lsbByte = (byte) (c & 0x00FF);

Basate en el siguiente diagrama de clases al momento de implemetnar todo lo mencionado


No crees nuevas clases, necesito que estas excepciones las crees dentro de la misma clase


I'll implement the required functionality for the File class based on the specifications. Let me first check the other related files to understand the complete structure.

Now I'll implement the complete File class with the constructor, methods, and exceptions as specified:

Edited
File.java+0-0
Implementation complete! Here's what I've added to the File.java class:

Constructor:

Initializes content as an empty ArrayList<Character> (not null)
Method addProperty(char[] newcontent):

Validates that newcontent is not null (throws InvalidContentException if null)
Validates that the file type is not IMAGE (throws WrongFileTypeException if IMAGE)
Adds all characters from newcontent to the existing content
Method getCRC32():

Returns 0 if content is empty (since calculateCRC32() doesn't handle empty arrays)
Converts ArrayList<Character> to byte[] by extracting both the least significant byte (LSB) and most significant byte (MSB) from each character
Uses FileUtils.calculateCRC32() to compute and return the CRC32 value
Custom Exceptions:

InvalidContentException - thrown when content is null
WrongFileTypeException - thrown when trying to add properties to an IMAGE file
Both exceptions are defined as static inner classes within the File class
